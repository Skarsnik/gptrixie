use GPT::Class;
use GPT::DumbGenerator;
use GPT::FileFilter;

module GPT::FileGenerator {
  our $merge-typedef-struct;
  my @modules-conf;
  my @files;
  my @user-excludes;

  sub read-gpt-file($filepath) is export {
    use MONKEY-SEE-NO-EVAL;
    my $gpt-conf = EVAL($filepath.IO.slurp);
    say $gpt-conf.perl, $gpt-conf.WHAT;
    if $gpt-conf ~~ Hash {
      $merge-typedef-struct = $gpt-conf<merge-struct-typedef>;
      @modules-conf.push($gpt-conf);
    }
    if $gpt-conf ~~ Array {
      for @$gpt-conf -> $mod-conf {
        say $mod-conf.perl , $mod-conf.WHAT;
        $merge-typedef-struct = True if ! $merge-typedef-struct.defined and $mod-conf<merge-struct-typedef>;
        @modules-conf.push($mod-conf);
      }
    }

  }

  sub generate-modules($att) is export {
    dg-init($att);
    for @modules-conf -> %conf {
      @files := %conf<files> if %conf<files>:exists;
      @user-excludes := %conf<exclude-files> if %conf<exclude-files>:exists;
      my @exclude-structs;
      @exclude-structs := %conf<exclude-structs> if %conf<exclude-structs>:exists;
      my @exclude-functions;
      @exclude-functions := %conf<exclude-functions> if %conf<exclude-functions>:exists;
      my @exclude-enums;
      @exclude-enums := %conf<exclude-enums> if %conf<exclude-enums>:exists;
      my $file = %conf<module-name>.subst('::', '-', :g) ~ '.pm6';
      note "Generating $file";
      my $fh = open $file, :w;
    
      $fh.say: '## This file was generated by the Great and Powerful Trixie';
      $fh.say: "use NativeCall;";
      $fh.say: "unit module %conf<module-name>;";
      $fh.say: 'sub GenMyLibName {';
      $fh.say: '  use NativeCall :TEST;';
      $fh.say: '  %*ENV<' ~ %conf<env-name> 
      ~ '> || guess_library_name(("' 
      ~ %conf<clib-name> ~  '", ' 
      ~ %conf<clib-abiversion>.perl ~ '))}';
      $fh.say: 'constant LIB = &GenMyLibName;';
      my %h = dg-generate-enums();
      $fh.say: '## Enumerations';
      my %sortedh = sort-by-file(%h.values, :context('e'));
      for %sortedh.kv -> $k, @v {
        $fh.say: "\n# == {$att.files{$k}} ==\n";
        for @v -> $ob {
          next if $ob<obj>.name (<=) @exclude-enums;
         $fh.say: $ob<p6str>;
        }
      }

      %h = dg-generate-structs();
      $fh.say: "";
      $fh.say: '## Structures' ~ "\n";
      %sortedh = sort-by-file(%h.values, :context('s'));
      for %sortedh.kv -> $k, @v {
        $fh.say: "\n# == {$att.files{$k}} ==\n";
        for @v.kv -> $i, $ob {
          if $ob<obj> ~~ Struct {
            if @v[$i + 1].defined and @v[$i + 1]<obj> ~~ AnonymousUnion and @v[$i + 1]<obj>.struct.defined {
              $fh.say: @v[$i + 1]<p6str>;
            }
          }
          if !($ob<obj> ~~ AnonymousUnion and $ob<obj>.struct.defined) {
            $fh.say: $ob<p6str>;
          }
        }
      }
      $fh.say: "";
      $fh.say: '## Extras stuff' ~ "\n";
      dg-generate-extra();
      %h = dg-generate-functions();
      $fh.say: '## Functions' ~ "\n";
      %sortedh = sort-by-file(%h.values, :context('f'));
      for %sortedh.kv -> $k, @v {
        $fh.say: "\n# == {$att.files{$k}} ==\n";
        for @v -> $ob {
          $fh.say: $ob<p6str>;
        }
      }
      $fh.say: "";
      $fh.say: '## Externs' ~ "\n";
      %h = dg-generate-externs();
      %sortedh = sort-by-file(%h.values);
      for %sortedh.kv -> $k, @v {
        $fh.say: "\n# == {$att.files{$k}} ==\n";
        for @v -> $ob {
          $fh.say: $ob<p6str>;
        }
      }
  }
  
  sub sort-by-file(@array, :$context) {
    my %toret;
    for @array -> %s {
      %toret{%s<obj>.file-id}.push(%s) if files-filter(%s<obj>.file-id, $att.files{%s<obj>.file-id}, @user-excludes, :context($context));
    }
    for %toret.keys -> $k {
      @(%toret{$k}).=sort: {$^a<obj>.start-line > $^b<obj>.start-line};
    }
    return %toret;
  }
    
  } 
}
